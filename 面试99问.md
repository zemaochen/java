# **轻松搞定 Java Web 面试题** --- Ay（阿毅）



### **前言**



大家好，我是Ay，大家也看到了，我们这次的讲课内容是《轻松搞定Java Web面试题》。录制这一系列的课程原因有多很多，待会会跟大家一一的来讲述。



说实话，程序员算是一个跳槽率比较高的一个职业。频繁跳槽算是常态。但是随便跳槽所带来的麻烦也算显然易见的，当然排除你是一个绝世高手。所以对于一般人来说。跳槽付出的代价肯定是有的。每一次跳槽，除了内推外，如果自己重新找下一家工作的话，那是需要准备很多东西的，你可能会在炎炎夏日中或者在白雪皑皑的冬天里，来回的奔波。这中间太多的心酸只有自己知道。特别是被一些好的公司刷掉之后，那种失落感，那种生无可恋的状态，是特别难受的。所以我才决定录制这样一套面试的教程，来减轻学员的压力，来帮助学员快速找到自己心仪的工作。



我自己曾经也面试过很多家公司，从阿里巴巴，爱奇艺，小米，饿了吗，携程，圆通到2345，一路拼杀过来。当然也面试过很多其它的公司。我也被大公司刷过，内心也有写不甘。因为开始没有一些面试大公司的经验，所以面试没有准备好。错过了很多的机会。所以也是希望学员可以从我这里吸取经验和教训，在自己的下一次面试中，能够很顺利，很轻松的进入下一家公司。



其实面试和相亲差不多，你要选择你中意的，别人也要选你。我们不要随时便便的就进入一家公司，应该多家比较和考虑，不能草率的决定接下来要陪伴在你身边的另一半。所以在进入面试之前，其实是有很多的东西要准备的。



- 你起码要准备一份精美的简历吧
- 你要注册各种招聘网站，然后投简历，等待面试的通知吧。
- 当你面试的时候，有些公司有面试题目，起码你要准备下面试题吧。
- 你还要了解下你所在的城市这个行业的薪资结构吧。
- 你内心要有自己期望的公司和期望的薪水吧。
- 等等，你都要考虑。



其实我给想要换工作的学员的建议是：除非特别原因（当然这个原因只有自己清楚），否则不要轻易的换工作。很多人换工作都是盲目跟风的，看到别人离职了，自己也跟着跳槽了。那这种跳槽是非常的草率的。在一家公司待的时间太短，你是学不到很多核心的技术的，而且你的晋升空间也会受阻。这类人频繁的出现在刚刚毕业或者毕业没多久的程序员。内心浮躁，技术能力又不强。因此我的建议是，毕业5年之前，你可以换工作，但是毕业5年之后，你就不要轻易的换工作了，一定要慎重慎重再慎重。



在面试过程中，当你技术面试过关之后，通常会有一个HR面试，一般到这里说明你基本已经通过了面试，但是你还是不能松懈的，这一面也是不容小觑的。比如HR经常会问你这些问题：

- 你为什么要离职啊？
- 你对我们公司还有什么要了解的吗？
- 你能支持经常出差吗？或者能支持经常加班吗？
- 你上一家公司的薪资是多少？
- 你手里拿到多少个offer了？
- 如果我们公司的薪资达不到你的要求，你会考虑留下来吗？
- 等等一系列的问题。

那这些问题我都会在这个系列的课程里面整理和讲解的。同时这个课程主要是针对笔试题，但是我会穿插一些类似上面这些问题的标准回答，请学员放心。而且这里讲到的很多的面试题都是大公司的真题，是自己亲身经历过，不是瞎编乱造的，希望学员放心。



### **课程介绍**



《轻松搞定Java Web面试》主要是帮助正在找工作的毕业生或者想找更好工作的社会人员而设计的一系列课程。本人根据自己在**阿里，爱奇艺，饿了么，携程，2345，小米，招商银行等等大公司的面试经验**而总结出这样的一套课程。希望可以快速帮助学员找到心仪的工作。课程设计到web开发的所有面试题，而且面试题会不断的补充。



### **课程目标**



帮助学员找到心仪的工作



### **课程计划**



至少每周更新3集



### Java



##### **String , StringBuffer 与 StringBuilder的区别**



这是一道重要而且高频被问到的面试题，如果这题都没有回答好，那面试官对你就大打折扣了。



**面试管：**String , StringBuffer 与 StringBuilder之间有什么区别吗？



**你的回答：**



对于字符串拼接：

**性能方面：**StringBuilder > StringBuffer > String（+）（for循环里面字符串拼接）

**线程安全：**StringBuilder （非线程安全，速度快），StringBuffer （线程安全，速度慢）

**如何选择：**StringBuilder （方法内，无线程安全问题），StringBuffer （有线程安全问题，使用它）



3点建议：（加分项）

- 当你连接 2 或 3 个String时，使用String.concat()。
- 如果你要连接多于3个String（不含3）,并且你能够精确预测出最终结果的长度，使用StringBuilder/StringBuffer，并设定初始化容量。
- 如果你要连接多于3个String（不含3）,并且你不能够精确预测出最终结果的长度，使用StringBundler。



【1】http://www.cnblogs.com/A_ming/archive/2010/04/13/1711395.html



面试官继续问题：

StringBuffer 为什么是线程安全的呢？



```
//StringBuffer源码
/**
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
@Override
public synchronized void getChars(int srcBegin, int srcEnd, char[] dst,int dstBegin){
    super.getChars(srcBegin, srcEnd, dst, dstBegin);
}
```



面试官可能还会继续问：



为什么加 synchronized 这个关键字，就是线程安全的呢？





##### **Vector，ArrayList，LinkedList的区别**



一、同步性 

ArrayList,LinkedList是不同步的，而Vestor是同步的。所以如果不要求线程安全的话，可以使用ArrayList或LinkedList，可以节省为同步而耗费的开销。但在多线程的情况下，有时候就不得不使用Vector了。当然，也可以通过一些办法包装ArrayList,LinkedList，使他们也达到同步，但效率可能会有所降低。 

二、数据增长 
从内部实现机制来讲ArrayList和Vector都是使用Objec的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%,所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。 

三、检索、插入、删除对象的效率 

ArrayList和Vector中，从指定的位置（用index）检索一个对象，或在集合的末尾插入、删除一个对象的时间是一样的，可表示为O(1)。但是，如果在集合的其他位置增加或移除元素那么花费的时间会呈线形增长：O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置。为什么会这样呢？以为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。 
LinkedList中，在插入、删除集合中任何位置的元素所花费的时间都是一样的—O(1)，但它在索引一个元素的时候比较慢，为O(i),其中i是索引的位置。 



一般大家都知道ArrayList和LinkedList的大致区别： 
​     1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 
​     2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 
​     3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 





##### **List如何去除重复数据**



【1】http://www.2cto.com/kf/201708/664237.html



```
/**
* AAAA AAAA BBBB BBBB CCCC CCCC CCCC CCCC
*/
public static void main(String[] args) {
         List<string> list = new ArrayList<string>();
         list.add("AAAA");
         list.add("AAAA");
         list.add("AAAA");
         list.add("BBBB");
         list.add("BBBB");
         list.add("BBBB");
         list.add("CCCC");
         list.add("CCCC");
         list.add("CCCC");
         list.add("DDDD");
         new Test().removeDuplicateWithOrder(list);
//      System.out.println(list);
}

      // 删除ArrayList中重复元素
public static void removeDuplicate(List list) {
    for (int i = 0; i < list.size() - 1; i++) {
        for (int j = list.size() - 1; j > i; j--) {
               if (list.get(j).equals(list.get(i))) {
                  list.remove(j);
               }
        }
    }
    System.out.println(list);
}

      // 方法二：通过HashSet剔除
      // 删除ArrayList中重复元素,add进去顺序就变了不考虑顺序的话可以使用
public static void removeDuplicate1(List list) {
         HashSet h = new HashSet(list);
         list.clear();
         list.addAll(h);
         System.out.println(list);
}

      // 方法三： 删除ArrayList中重复元素，保持顺序
      // 删除ArrayList中重复元素，保持顺序
public static void removeDuplicateWithOrder(List list) {
         Set set = new HashSet();
         List newList = new ArrayList();
         for (Iterator iter = list.iterator(); iter.hasNext();) {
            Object element = iter.next();
            if (set.add(element))
               newList.add(element);
         }
         list.clear();
         list.addAll(newList);
         System.out.println(" remove duplicate " + list);
}
```



##### **自己手动实现一个线程池**

【1】http://blog.csdn.net/w2393040183/article/details/52177572



##### **Java字节流和字符流的区别**



经过以上的描述，我们可以知道字节流与字符流之间主要的区别体现在以下几个方面：

- 字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元。
- 字节流默认不使用缓冲区；字符流使用缓冲区。
- 字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。


所以对于字节流和字符流的选择，我们建议：在开发中尽量都去使用字节流进行操作，因为字节流可以处理图片、音乐、文字，也可以方便进行传输或者文字的编码转换；如果在处理中文的使用考虑字符流。

【1】http://bbs.itheima.com/thread-277923-1-1.html




##### **多线程实现生产者/消费者模式**







##### **在Java中什么是线程调度？**



#####  **线程与进程的区别？**



http://blog.csdn.net/yaosiming2011/article/details/44280797



**死锁与活锁区别，死锁与饥饿的区别？**

http://www.cnblogs.com/lance43990740/p/6853631.html

##### **在线程中你怎么处理不可捕捉异常**

【1】http://blog.csdn.net/Dxx23/article/details/44775735



**多线程上下文切换**

【1】http://www.cnblogs.com/szlbm/p/5505707.html



##### **HashTable，HashMap，TreeMap的区别**

【1】http://blog.csdn.net/natian306/article/details/10858097

【2】http://www.cnblogs.com/tengpan-cn/p/5909395.html





##### IO,BIO,NIO,AIO编程模型

【1】http://blog.csdn.net/anxpp/article/details/51512200
【2】http://blog.csdn.net/jiaomingliang/article/details/47684713

如果你想吃一份宫保鸡丁盖饭： 

同步阻塞：你到饭馆点餐，然后在那
等着，还要一边喊：好了没啊！ 

同步非阻塞：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！ 

异步阻塞：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。 

异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。

##### **TreeMap实现原理**

http://blog.csdn.net/chenssy/article/details/26668941



##### **HashMap实现原理**



http://blog.csdn.net/vking_wang/article/details/14166593



##### **如何判断一棵树(tree)是对称的**

【1】http://blog.csdn.net/yangmm2048/article/details/45689561



##### **如何生成全球唯一的编码**



##### 关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。





##### **map实现按照key字典排序，并且按照顺序打印key 和 value?**



【1】http://blog.csdn.net/bwgang/article/details/7879563



##### **反射**





##### **syschronized实现原理**

【1】http://www.cnblogs.com/paddix/p/5367116.html







##### **syschronized与重入锁ReenTrantLock的区别**

可重入性：
从名字上理解，ReenTrantLock的字面意思就是再进入
的锁，其实synchronized关键字所使用的锁也是可重
入的，两者关于这个的区别不大。两者都是同
一个线程每次进入一次，锁的计数器都自增1，
所以要等到锁的计数器下降为0时才能释放锁。
三.synchronized和ReentrantLock的区别
除了synchronized的功能,多了三个高级功能.
等待可中断,公平锁,绑定多个Condition.

- 1.等待可中断
  在持有锁的线程长时间不释放锁的时候,等待的线程可以选择放弃等待.   tryLock(long timeout, TimeUnit unit)
- 2.公平锁按照申请锁的顺序来一次获得锁称为公平锁.synchronized的是非公平锁,ReentrantLock可以通过构造函数实现公平锁.    new RenentrantLock(boolean fair)
- 3.绑定多个Condition
  通过多次newCondition可以获得多个Condition对象,可以简单的实现比较复杂的线程同步的功能.通过await(),signal();





##### **Java多线程**

- wait（），notify（）和notifyAll（）

  ​

##### **抽象类与接口的区别**



【1】http://www.cnblogs.com/beanmoon/archive/2012/12/06/2805221.html

##### **equals hashcode ** 



【1】http://blog.csdn.net/ftx2540993425/article/details/51206130
【2】http://www.cnblogs.com/Qian123/p/5703507.html





##### **lambda优点**
【1】http://developer.51cto.com/art/201304/387681.htm

##### **关键字transient**

【1】http://blog.csdn.net/d12345678a/article/details/54178659

##### **JDK和JRE的区别是什么**

Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK) 是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程 序。

JDK中包含JRE，JRE中包含JVM。

JDK中包含的JRE主要是为JDK自带的开发工具提供运行环境，与JDK并列的那个JRE是为用户编写的JAVA代码提供运行环境的。

classpath配置的是JDK的lib目录，path配置的是JDK的bin目录。


##### **Java到底是不是一种纯面向对象语言？**

【1】https://news.cnblogs.com/n/548327/

#####  **HTTP请求的header头解析**

http://blog.csdn.net/hufan11100914/article/details/48029633

##### **如何判断一个对象已经被回收** 

【1】http://blog.csdn.net/canot/article/details/51037938

##### **假如有两个线程，一个线程A，一个线程B都会访问一个加锁方法，可能存在并发情况，但是线程B访问频繁，线程A访问次数很少，问如何优化。(然后面试官说有了解过重度锁和轻度锁吗)**



##### **有三个线程ID分别是A、B、C,请有多线编程实现，在屏幕上循环打印10次ABCABC…** 



##### **两个有序数组合并为一个有序数组**

【1】http://www.cnblogs.com/A_ming/archive/2010/04/15/1712313.html



##### **JAVA值类型和引用类型的区别**

【1】http://www.cnblogs.com/InterLinkXiaoCai/p/4951889.html



##### **基本类型转换**

【1】http://blog.csdn.net/u011583105/article/details/16349095



##### **递归算法笔试题**



```
 /*
 * 一列数的规则如下: 1、1、2、3、5、8、13、21、34...... 求第30位数是多少， 用递归算法实现。
 **/
static int find30(int n){
        if (n <= 0)
            return 0;
        else if(n > 0 && n <= 2)
            return 1;
        return find30(n-1)+find30(n-2);
}
```



##### **内存泄漏和内存溢出区别**

Java中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄露。

【1】http://blog.csdn.net/buutterfly/article/details/6617375



##### **内存溢出和内存泄漏的原因**

【1】http://www.cnblogs.com/bluestorm/archive/2012/08/06/2625604.html

【2】http://blog.csdn.net/anxpp/article/details/51325838

【3】http://blog.csdn.net/shanyu1198124123/article/details/52414392



##### 子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程循环100次，如此循环50次

【1】http://www.cnblogs.com/ysloong/p/6370104.html



##### **condition的作用**



【1】http://blog.csdn.net/ghsau/article/details/7481142



##### **现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行**



##### Java多线程中join方法的理解



【1】http://uule.iteye.com/blog/1101994



##### **equals() 与 hashcode()**



##### **Lock接口比synchronized块的优势是什么**



##### **java中wait和sleep方法的不同**



最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。

【1】http://blog.csdn.net/clam_clam/article/details/6803667



**用Java实现阻塞队列**



【1】http://blog.csdn.net/chenchaofuck1/article/details/51660119

【2】http://blog.csdn.net/ghsau/article/details/7481142



**java中volatile关键字理解**



【1】http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html

【2】http://www.infoq.com/cn/articles/java-memory-model-4/



区别：

  一、volatile是变量修饰符，而synchronized则作用于一段代码或方法。

 二、volatile只是在线程内存和“主”内存间同步某个变量的值；而synchronized通过锁定和解锁某个监视器同步所有变量的值。显然synchronized要比volatile消耗更多资源



##### **什么是竞争条件？你怎样发现和解决竞争？**

【1】http://blog.csdn.net/hourui93/article/details/48596259



##### **你将如何使用thread dump？你将如何分析Thread dump**



【1】http://blog.csdn.net/rachel_luo/article/details/8920596



##### **在Java中CycliBarriar和CountdownLatch有什么区别**



【1】http://blog.csdn.net/kjfcpua/article/details/7300286



##### **Java并发编程-Executor框架集**



【1】http://www.cnblogs.com/MOBIN/p/5436482.html



##### **对象的四种引用类型**

【1】http://www.cnblogs.com/Bob-FD/archive/2012/09/08/java.html



### **Spring**

【1】http://www.importnew.com/15851.html#ioc_di



**Spring好在哪里**

 轻量：Spring 是轻量的，基本的版本大约2MB。
 控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。
 面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。
 容器：Spring 包含并管理应用中对象的生命周期和配置。
 MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。
 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。
 异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。



##### **spring 实现日志管理**



##### Spring框架有哪些主要模块**

##### **控制反转(IOC)？什么是依赖注入（DI）?**

##### **IOC(DI)原理**

##### **依然注入三种实现方式**

##### **Spring Bean作用域之间的区别**

##### **Spring有几种配置方式**

- 基于XML的配置
- 基于注解的配置
- 基于Java的配置

##### **请解释Spring Bean的生命周期**

##### **自动装配模式的区别**

##### **如何开启基于注解的自动装配**

##### **Spring框架中有哪些不同类型的事件**

##### **BeanFactory和ApplicationContext有什么区别**

##### **三种较常见的 ApplicationContext 实现方式**

- ClassPathXmlApplicationContext
- FileSystemXmlApplicationContext
- XmlWebApplicationContext

##### **如何用基于Java配置的方式配置Spring**

Spring对Java配置的支持是由@Configuration注解和@Bean注解来实现的。

##### **Spring中注入一个Java Collection**

<list> :   该标签用来装配可重复的list值。
<set> :    该标签用来装配没有重复的set值。
<map>:   该标签可用来注入键和值可以为任何类型的键值对。
<props> : 该标签支持注入键和值都是字符串类型的键值对。

##### **FileSystemResource和ClassPathResource有何区别**

##### **Spring 框架中都用到了哪些设计模式**

- 代理模式—在AOP和remoting中被用的比较多。
- 单例模式—在spring配置文件中定义的bean默认为单例模式。
- 模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。
- 前端控制器—Spring提供了DispatcherServlet来对请求进行分发。
- 视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。
- 依赖注入—贯穿于BeanFactory / ApplicationContext接口的核心理念。
- 工厂模式—BeanFactory用来创建对象的实例。

### **SpringBoot**

### **Struts**

### **Servlet**

**Post，Get区别**

Session, Cookie区别

Servlet的生命周期



HTTP 报文包含内容
简述三次握手和四次挥手





TCP是TCP/IP的第三层传输层，对应OSI的第四层传输层； 
IP是TCP/IP的第二层互联层，对应OSI的第三层网络层。



### **数据库**



##### **postgresql数据库比mysql好在哪里？**



【1】http://www.cnblogs.com/zhangpengme/archive/2011/12/01/2271092.html



##### **数据库的左连接，右连接，内连接，外连接**

【1】http://blog.csdn.net/zj972535075/article/details/50364813




##### **数据库四个范式**

【1】http://blog.csdn.net/famousdt/article/details/6921622
【2】http://www.jb51.net/article/19312.htm


##### **数据库事务隔离级别**

四个事务隔离级别概念和脏读、不可重复读、幻读这几类问题的概念。

- Read uncommitted
- Read committed
- Repeatable read
- Serializable
  这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。

【1】http://blog.csdn.net/fg2006/article/details/6937413

##### **乐观锁和悲观锁**

乐观锁和悲观锁的概念，乐观锁实现：第一种是使用版本号（hibernate乐观锁），第二种是使用时间戳。

【１】http://www.cnblogs.com/wang-meng/p/5506943.html


##### **排他锁、共享锁**

排他锁概念：
**注意：**排他锁指的是一个事务在一行数据加上排他锁后，其他事务不能再在其上加其他的锁。

共享锁概念：
**注意：**一个事务获取了共享锁，在其他查询中也只能加共享锁或不加锁。

**注意：**排他锁与共享锁不能存在同一数据上。

【1】http://blog.csdn.net/c466254931/article/details/53463596

##### **数据库索引类型及实现方式**

**索引的优缺点:**

唯一索引：   UNIQUE    
主键索引：   primary key
聚集索引（也叫聚簇索引）：cluster **概念**等等

【1】http://www.cnblogs.com/barrywxx/p/4351901.html
【2】http://www.cnblogs.com/terryglp/articles/2450197.html

 **SQL联合索引 与 单一列的索引区别:**

【1】http://blog.csdn.net/shellching/article/details/7655793

**索引的实现方式：**

- B+树
- 散列索引
- 位图索引：位图索引是一种针对多个字段的简单查询设计一种特殊的索引，适用范围比较小，**只适用于字段值固定并且值的种类很少的情况，比如性别，只能有男和女，或者级别，状态等等，并且只有在同时对多个这样的字段查询时才能体现出位图的优势**。


##### **SQL优化**


##### **执行计划**

explain语句

【1】http://toplchx.iteye.com/blog/2091860

##### **事务4大特性**

- 原子性(Atomicity)
- 一致性(Consistency)    
- 分离性(亦称独立性Isolation)
- 持久性(Durability)

原子性(Atomicity)：要么全部执行，要么完全不执行

一致性(Consistency) 实例：拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

【1】http://www.cnblogs.com/fjdingsd/p/5273008.html



##### **在1亿条用户记录里，如何快速查询统计出看了5个电影以上的用户？**

- 办法一，建立分区表，按照用户浏览的记录数进行分区。
- 办法二，单独建立一张表，存放这样的信息。这张表就两个列，用户id和浏览量，这种思想叫冗余表。但是需要注意的是冗余表的建立，可以大幅提供效率，但会增加数据库维护的成本，需要综合考虑是否合适。
- 办法三，使用mongodb这样的nosql数据库。mongodb是一个文档型的nosql数据库，创建表的时候，增加两个列，一个保存浏览量，一个保存具体的浏览记录。这种方式跟冗余表的思想是一样的

【1】http://blog.csdn.net/lgb934/article/details/8662956



##### **关于数据库where和having的区别，执行顺序、group by 与having如何使用。**

http://blog.csdn.net/my773962804/article/details/51538790?_t_t_t=0.17189185717143118




### **Redis**

##### **分布式锁的实现**


【1】https://my.oschina.net/u/1995545/blog/366381


##### **5种数据类型**

- 全局key操作
- String（字符串）
- Hashes类型:(map)
- List类型
- set类型
- Sorted-Sets类型

【1】http://blog.csdn.net/huangwenyi1010/article/details/51354188

##### **两种持久化方式及原理**

**Redis的持久化策略：**
rdb:快照形式是直接把内存中的数据保存到一个dump文件中，定时保存，保存策略
aof：把所有的对redis的服务器进行修改的命令都存到一个文件里，命令的集合

【1】http://blog.csdn.net/u010785685/article/details/52366977

##### **与Memcache区别**

redis和memecache的不同在于：

- 存储方式：
    memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小
    redis有部份存在硬盘上，这样能保证数据的持久性，支持数据的持久化（笔者注：有快照和AOF日志两种持久化方式，在实际应用的时候，要特别注意配置文件快照参数，要不就很有可能服务器频繁满载做dump）。
- 数据支持类型：
    redis在数据支持上要比memecache多的多。
- 使用底层模型不同：
    新版本的redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
- 运行环境不同：
    redis目前官方只支持Linux 上去行，从而省去了对于其它系统的支持，这样的话可以更好的把精力用于本系统 环境上的优化，虽然后来微软有一个小组为其写了补丁。但是没有放到主干上



Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等；  

Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；  

虚拟内存--Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；  

过期策略--memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10；  

分布式--设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从；  

存储数据安全--memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；  

灾难恢复--memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；  

Redis支持数据的备份，即master-slave模式的数据备份；  

应用场景不一样：Redis出来作为NoSQL数据库使用外，还能用做消息队列、数据堆栈和数据缓存等；Memcached适合于缓存SQL语句、数据集、用户临时性数据、延迟查询数据和session等。 





【1】http://blog.csdn.net/sunmenggmail/article/details/36176029


##### redis是多线程还是单线程

【1】http://www.cnblogs.com/syyong/p/6231326.html

##### **订阅/发布**


【1】http://blog.csdn.net/huangwenyi1010/article/details/51376197

##### **分布式（主从模式）**


##### **队列**



### **设计模式**



##### **门面模式的解释，适用场合**

【1】http://www.cnblogs.com/lthIU/p/5860607.html






### **Hibernate**

Hibernate工作原理

Hibernate四种查询

Hibernate的3种对象状态

【1】http://blog.csdn.net/huangwenyi1010/article/details/68923405#t9


### **JVM虚拟机**

JVM虚拟机内存模型

堆内存模型

【1】http://www.cnblogs.com/AloneSword/p/4262255.html

**垃圾回收算法：**

- 引用计数算法
- 根搜索算法
- 标记-清除算法
- 标记-整理算法
- 分代收集算法
- CMS算法：Concurrent Mark Sweep/CMS是一款并发、使用标记-清除算法的gc。（http://www.cnblogs.com/Leo_wl/p/5393300.html 或者 http://blog.csdn.net/aibisoft/article/details/27555793）


### 	**Linux常用命令**

##### **基础命令**

##### **管道命令**

【1】http://www.cnblogs.com/mrzero/p/3985302.html

### **Tomcat**

##### **Tomcat性能调优**

- JVM参数调优
- NIO协议
- 线程池和连接数配置
- 禁用AJP协议



##### **Tomcat启动时加载数据到缓存**

【1】http://blog.csdn.net/cnctcom/article/details/52861955



### **Git**

##### **git如何回退到某个历史版本**

【1】http://blog.csdn.net/newjueqi/article/details/49098123

##### **SVN和Git优缺点比较**

【1】http://blog.csdn.net/yuwq123/article/details/52748009

### **JDBC**

##### **Statement与PreparedStatement的区别?**

【1】http://blog.csdn.net/haorengoodman/article/details/23995347



### **MyBatis**



##### **MyBatis如何唯一标识一个SQL语句**



##### **Hibernate和MyBatis如何映射一对多关系**

【1】http://www.cnblogs.com/liujiayun/p/5814158.html

【2】http://blog.csdn.net/suwu150/article/details/52896459





### 前端**



##### **ajax原理**

【1】http://www.cnblogs.com/mingmingruyuedlut/archive/2011/10/18/2216553.html



### **算法面试题**







现在有1000瓶药水，其中至多有1瓶是有剧毒的，现在给你10只狗，在24小时内通过小狗试药的方式，

找出那些药有毒或者全部没毒（小狗服完药20小时之后才能判断是否中毒）。

【1】http://blog.csdn.net/sancho_lai/article/details/3218786







 

### Java中Atomic包的原理和分析



【1】http://blog.csdn.net/tanga842428/article/details/52765537





下面是笔者整理的jdk自带的常用命令行工具的使用方法，全部原创，转载请注明出处，并贴上链接，谢谢！

- [**jps命令使用**](http://blog.csdn.net/winwill2012/article/details/46319033)
- [**jstat命令使用**](http://blog.csdn.net/winwill2012/article/details/46319355)
- [**jinfo命令使用**](http://blog.csdn.net/winwill2012/article/details/46336839)
- [**jmap命令使用**](http://blog.csdn.net/winwill2012/article/details/46337339)
- [**jhat命令使用**](http://blog.csdn.net/winwill2012/article/details/46337535)
- [**jstack命令使用**](http://blog.csdn.net/winwill2012/article/details/46364339)
- [**jcmd命令使用**](http://blog.csdn.net/winwill2012/article/details/46364849)



### **后台系统怎么防止请求重复提交**



【1】http://blog.csdn.net/hshl1214/article/details/46635905





### **有没有有顺序的Map 实现类，如果有，他们是怎么保证有序的。**



【1】http://www.cnblogs.com/children/archive/2012/10/02/2710624.html





### **反射中，Class.forName 和 ClassLoader 区别**







### **描述动态代理的几种实现方式，分别说出相应的优缺点。**



【1】http://blog.csdn.net/kyi_zhu123/article/details/52644624





### **在自己的代码中，如果创建一个 java.lang.String 对象，这个对象是否可以被类加载器加载？为什么。**



1. http://blog.csdn.net/bbirdsky/article/details/8283143  
2. 字符串类(Java.lang.String)是Java中使用最多的类，也是最为特殊的一个类，很多时候，我们对它既熟悉又陌生。在很多面试题中经常用String大做文章，只要掌握了String特性，对付它们就不再是困难了。  
3. 1、从根本上认识java.lang.String类和String池  
4. 首先，我建议先看看String类的源码实现，这是从本质上认识String类的根本出发点。  
5. 从源码中可以看到：  
6. String类是final的，不可被继承。public final class String。  
7. String类是的本质是字符数组char[], 并且其值不可改变。private final char value[];  
8. ​
9. 然后打开String类的API文档，从API中可以发现：  
10. String类对象有个特殊的创建的方式，就是直接指定比如String x = "abc"，"abc"就表示一个字符串对象。而x是"abc"对象的地址，也叫做"abc"对象的引用。  
11. String对象可以通过“+”串联。串联后会生成新的字符串。也可以通过concat()来串联，这个后面会讲述。  
12. Java运行时会维护一个String Pool（String池），JavaDoc翻译很模糊“字符串缓冲区”。String池用来存放运行时中产生的各种字符串，并且池中的字符串的内容不重复。而一般对象不存在这个缓冲池，并且创建的对象仅仅存在于方法的堆栈区。  
13. ​
14. 2、创建字符串的方式  
15. 创建字符串的方式很多，归纳起来有三类：  
16. 使用new关键字创建字符串，比如String s1 = new String("abc");  
17. 直接指定。比如String s2 = "abc";  
18. 使用串联生成新的字符串。比如String s3 = "ab" + "c"。  
19. ​
20. 3、String对象的创建的特性  
21. String对象的创建也很讲究，关键是要明白其原理。  
22. ​
23. 特性1：  
24. 当使用任何方式来创建一个字符串对象s时，Java运行时（运行中JVM）会拿着这个字符串的内容在String池中找是否存在内容相同的字符串对象，如果不存在，则在池中创建一个字符串s，否则，不在池中添加。  
25. ​
26. 特性2：  
27. Java中，只要使用new关键字来创建对象，则一定会（在堆区或栈区）创建一个新的对象。  
28. ​
29. 特性3：  
30. 使用直接指定、使用纯字符串串联或者在编译期间可以确定结果的变量表达式来创建String对象，则仅仅会检查维护String池中的字符串，池中没有就在池中创建一个，有则罢了！但绝不会在堆栈区再去创建该String对象；  
31. 1、 直接指定，例如：下面代码运行结果为true；  
32. String str1 = "abc";  
33. String str2 = "abc";  
34. System.out.println(str1 == str2);  
35. 2、 使用纯字符串串联，例如：下面代码运行结果为true；  
36. String str1 = "abc";  
37. String str2 = "ab" + "c";  
38. System.out.println(str1 == str2);  
39. 3、 在编译期间可以确定结果的变量表达式，例如：下面代码运行结果为true。  
40. final String str1 = "c"; //final类型的变量在编译时当常量处理  
41. String str2 = "ab" + "c";  
42. String str3 = "ab" + str1;  
43. System.out.println(str2==str3);  
44. ​
45. 否则使用包含编译期间无法确定结果的变量的表达式来创建String对象，则不仅会检查维护String池，而且还会在堆栈区创建一个String（由StringBuilder.toString()生成）对象。  
46. 1、普通变量表达式进行创建字符串，例如：下面代码运行结果为false；  
47. String str1 = "c";  
48. String str2 = "ab" + "c";  
49. String str3 = "ab" + str1;  
50. System.out.println(str2==str3);  



##### **Java8新特性有那些**





##### **正则表达式判断字符串是否含有数字**





**实现一个高并发的点赞功能**





**亿级数据的分页查询**





